import PerfectSecrecy.OTP

/-
  Proof that reusing the key in OTP breaks perfect secrecy. We create
  a counterexample from reuse of a key that breaks perfect secrecy.
  Fixing n = 2 and plaintext pairs (00,00) and (00,11) will do.
-/

open PMF
open Bitvec

namespace OTP_reuse_n2

-- Fix n = 2
variable {n : ℕ}
local notation "N2" => (2 : ℕ)

-- Enc2_dist defined to be the distribution of ciphertext pairs
-- when the same key is used to encrypt two messages m1 and m2.
noncomputable
def Enc2_dist_n2 (m1 m2 : BitVec 2) : PMF (BitVec 2 × BitVec 2) := do
  let k ← (OTP_Gen : PMF (BitVec 2))
  PMF.pure (OTP_Enc k m1, OTP_Enc k m2)

-- Fix two pairs of messages (m10,m20) and (m11,m21).
def m10 : BitVec 2 := 0 -- 00
def m20 : BitVec 2 := 0 -- 00
def m11 : BitVec 2 := 0 -- 00
def m21 : BitVec 2 := 3 -- 11


theorem reuse_breaks_perfect_secrecy_n2 :
  ∃ c : BitVec 2 × BitVec 2,
    Enc2_dist_n2 m10 m20 c ≠ Enc2_dist_n2 m11 m21 c := by

  -- choose c generated by taking k = 0 and encrypting (m10,m20)
  let k0 : BitVec 2 := 0
  let c := (OTP_Enc k0 m10, OTP_Enc k0 m20)
  use c

  have p1 : Enc2_dist_n2 m10 m20 c = 1/4 := by
            -- = (1 : ENNReal) / (Fintype.card (BitVec 2) : ENNReal) := by
    unfold Enc2_dist_n2 OTP_Gen
    simp [Bind.bind,PMF.bind_apply, PMF.pure_apply, PMF.uniformOfFintype]
    unfold OTP_Enc m10 m20
    simp [c, OTP_Enc, k0,m10,m20]
    have (a b : BitVec 2) : a = b ↔ b = a := by exact eq_comm
    simp [this]
    norm_cast


  have p2 : Enc2_dist_n2 m11 m21 c = 0 := by
    unfold Enc2_dist_n2 OTP_Gen
    simp [Bind.bind,PMF.bind_apply, PMF.pure_apply, PMF.uniformOfFintype]
    intro k
    unfold OTP_Enc m11 m21
    simp [c,OTP_Enc,k0,m10,m20]
    intro kval
    rw [kval.symm]
    norm_num
    norm_cast

  rw [p1,p2]
  norm_num

end OTP_reuse_n2
